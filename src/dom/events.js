// Generated by CoffeeScript 1.6.2
define(['cell/util/ev', 'cell/dom/browser', 'cell/dom/data'], function(ev, browser, data) {
  var DOMUnbindAllEvents, addEventListenerFn, createEventHandler, eventHandlerDestroy, onFn, removeEventListenerFn;

  addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
    element.addEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.attachEvent("on" + type, fn);
  };
  removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
    element.removeEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.detachEvent("on" + type, fn);
  };
  eventHandlerDestroy = function() {
    DOMUnbindAllEvents(this.elem, this.events);
  };
  createEventHandler = function(element, events) {
    var eventHandler;

    eventHandler = function(event, type) {
      var evs, fc, prevent, _i, _len;

      if (!event.preventDefault) {
        event.preventDefault = function() {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function() {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (event.defaultPrevented == null) {
        prevent = event.preventDefault;
        event.preventDefault = function() {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function() {
        return event.defaultPrevented;
      };
      if (evs = events[type || event.type]) {
        for (_i = 0, _len = evs.length; _i < _len; _i++) {
          fc = evs[_i];
          fc[0].call(fc[1] || element, event);
        }
      }
      if (browser.msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    eventHandler.events = events;
    eventHandler.destroy = eventHandlerDestroy;
    return eventHandler;
  };
  DOMUnbindAllEvents = function(element, events) {
    var type;

    for (type in events) {
      removeEventListenerFn(element, type, events[type]);
      delete events[type];
    }
  };
  return {
    on: onFn = function(element, type, fn, ctx) {
      var counter, eventFns, events, handle;

      if (!(events = data.get(element, 'events'))) {
        data.set(element, 'events', events = {});
      }
      if (!(handle = data.get(element, 'handle'))) {
        data.set(element, 'handle', handle = createEventHandler(element, events));
      }
      if (!(eventFns = events[type])) {
        if (type === 'mouseenter' || type === 'mouseleave') {
          counter = 0;
          events.mouseenter = [];
          events.mouseleave = [];
          onFn(element, 'mouseover', function(event) {
            counter++;
            if (counter === 1) {
              return handle(event, 'mouseenter');
            }
          });
          onFn(element, 'mouseout', function(event) {
            counter--;
            if (counter === 0) {
              return handle(event, 'mouseleave');
            }
          });
        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type];
      }
      eventFns.push([fn, ctx]);
    },
    off: function(element, type, fn) {
      var events;

      if (events = data.get(element, 'events')) {
        if (type != null) {
          if (fn != null) {
            ev.rm(events[type], fn, 0);
          } else {
            removeEventListenerFn(element, type, events[type]);
            delete events[type];
          }
        } else {
          DOMUnbindAllEvents(element, events);
        }
      }
    }
  };
});

/*
//@ sourceMappingURL=events.map
*/
