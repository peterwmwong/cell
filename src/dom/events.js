// Generated by CoffeeScript 1.4.0

define(['dom/browser', 'dom/data'], function(browser, data) {
  var DOMUnbindAllEvents, addEventListenerFn, arrayRemove, bindFn, createEventHandler, indexOf, removeEventListenerFn;
  indexOf = Array.prototype.indexOf ? function(array, el) {
    return array.indexOf(el);
  } : function(array, el) {
    var a, i;
    i = 0;
    while (a = array[i++]) {
      if (a === el) {
        return i - 1;
      }
    }
    return -1;
  };
  arrayRemove = function(array, el) {
    array.splice(indexOf(array, el), 1);
  };
  addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
    element.addEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.attachEvent("on" + type, fn);
  };
  removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
    element.removeEventListener(type, fn, false);
  } : function(element, type, fn) {
    element.detachEvent("on" + type, fn);
  };
  createEventHandler = function(element, events) {
    var eventHandler;
    eventHandler = function(event, type) {
      var fn, prevent, _i, _len, _ref;
      if (!event.preventDefault) {
        event.preventDefault = function() {
          event.returnValue = false;
        };
      }
      if (!event.stopPropagation) {
        event.stopPropagation = function() {
          event.cancelBubble = true;
        };
      }
      if (!event.target) {
        event.target = event.srcElement || document;
      }
      if (event.defaultPrevented == null) {
        prevent = event.preventDefault;
        event.preventDefault = function() {
          event.defaultPrevented = true;
          prevent.call(event);
        };
        event.defaultPrevented = false;
      }
      event.isDefaultPrevented = function() {
        return event.defaultPrevented;
      };
      _ref = events[type || event.type];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fn = _ref[_i];
        fn.call(element, event);
      }
      if (browser.msie <= 8) {
        event.preventDefault = null;
        event.stopPropagation = null;
        return event.isDefaultPrevented = null;
      } else {
        delete event.preventDefault;
        delete event.stopPropagation;
        return delete event.isDefaultPrevented;
      }
    };
    eventHandler.elem = element;
    return eventHandler;
  };
  DOMUnbindAllEvents = function(element, events) {
    var type;
    for (type in events) {
      removeEventListenerFn(element, type, events[type]);
      delete events[type];
    }
  };
  return {
    bind: bindFn = function(element, type, fn) {
      var counter, eventFns, events, handle, _i, _len, _ref;
      if (!(events = data.get(element, 'events'))) {
        data.set(element, 'events', events = {});
      }
      if (!(handle = data.get(element, 'handle'))) {
        data.set(element, 'handle', handle = createEventHandler(element, events));
      }
      _ref = type.split(' ');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        type = _ref[_i];
        if (!(eventFns = events[type])) {
          if (type === 'mouseenter' || type === 'mouseleave') {
            counter = 0;
            events.mouseenter = [];
            events.mouseleave = [];
            bindFn(element, 'mouseover', function(event) {
              counter++;
              if (counter === 1) {
                return handle(event, 'mouseenter');
              }
            });
            bindFn(element, 'mouseout', function(event) {
              counter--;
              if (counter === 0) {
                return handle(event, 'mouseleave');
              }
            });
          } else {
            addEventListenerFn(element, type, handle);
            events[type] = [];
          }
          eventFns = events[type];
        }
        eventFns.push(fn);
      }
    },
    unbind: function(element, type, fn) {
      var events, handle;
      handle = data.get(element, 'handle');
      events = data.get(element, 'events');
      if (!handle) {
        return;
      }
      if (type != null) {
        if (fn != null) {
          arrayRemove(events[type], fn);
        } else {
          removeEventListenerFn(element, type, events[type]);
          delete events[type];
        }
      } else {
        DOMUnbindAllEvents(element, events);
      }
    }
  };
});
