// Generated by CoffeeScript 1.6.1

define(['util/hash', 'util/fn', 'util/type', 'util/defer'], function(hash, fn, type, defer) {
  var addLog, allChanges, evaluateAndMonitor, log, logStack, onChange, onChangeCalled, watches, _onChange;
  logStack = [];
  onChangeCalled = log = false;
  addLog = function(obj, event) {
    var key;
    if (!log.l[key = event + (obj.$$hashkey || hash(obj))]) {
      log.s += key;
      log.l[key] = {
        o: obj,
        e: event
      };
    }
  };
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      evaluateAndMonitor(changes[key]);
    }
  };
  onChange = function() {
    allChanges[hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      defer(_onChange);
    }
  };
  return {
    _eam: evaluateAndMonitor = function(context) {
      var curLog, eventKey, prevLog, value;
      logStack.push(log);
      log = {
        s: '',
        l: curLog = {},
        c: {}
      };
      value = context.e();
      if (log.s !== context.s) {
        if (prevLog = context.l) {
          for (eventKey in prevLog) {
            if (curLog[eventKey]) {
              delete curLog[eventKey];
            } else {
              prevLog[eventKey].o.off(prevLog[eventKey].e, void 0, context);
            }
          }
        }
        for (eventKey in curLog) {
          curLog[eventKey].o.on(curLog[eventKey].e, onChange, context);
        }
        context.s = log.s;
        context.l = curLog;
      }
      log = logStack.pop();
      context.f(value);
    },
    addCol: function() {
      if (log) {
        log.c[this.$$hashkey || hash(this)] = true;
        addLog(this, 'add');
        addLog(this, 'remove');
      }
    },
    addModel: function(key) {
      var obj;
      if (log) {
        addLog(((obj = this.collection) && log.c[obj.$$hashkey || hash(obj)] ? obj : this), (key ? "change:" + key : 'all'));
      }
    },
    suspendWatch: function(f) {
      var suspendedLog;
      suspendedLog = log;
      log = false;
      try {
        f();
      } catch (_error) {}
      log = suspendedLog;
    },
    unwatch: function(key) {
      var context, i, w;
      if (w = watches[key = hash(key)]) {
        delete watches[key];
        i = 0;
        while ((context = w[i++])) {
          for (key in context.l) {
            context.l[key].o.off(void 0, void 0, context);
          }
        }
      }
    },
    watch: function(keyObj, e, f, callContext) {
      var context, key;
      callContext || (callContext = keyObj);
      if (!type.isF(e)) {
        f.call(callContext, e);
      } else {
        (watches[key = hash(keyObj)] || (watches[key] = [])).push(context = {
          e: fn.b0(e, keyObj),
          f: fn.b1(f, callContext)
        });
        evaluateAndMonitor(context);
        return context;
      }
    }
  };
});
