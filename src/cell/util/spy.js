// Generated by CoffeeScript 1.4.0

define(['util/hash'], function(hash) {
  var allChanges, doAfter, log, onChange, onChangeCalled, watches, _onChange;
  log = false;
  doAfter = window.requestAnimationFrame || function(f) {
    return setTimeout(f, 0);
  };
  onChangeCalled = false;
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      changes[key].f(changes[key].e());
    }
  };
  onChange = function() {
    allChanges[hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      doAfter(_onChange);
    }
  };
  return {
    addCol: function() {
      if (log) {
        log.c[hash(this)] = this;
      }
    },
    addModel: function(key) {
      var entry, hashkey, k, obj, _ref;
      if (log) {
        _ref = {
          m: this,
          d: this.collection
        };
        for (k in _ref) {
          obj = _ref[k];
          if (!(obj)) {
            continue;
          }
          if (!(entry = log[k][hashkey = hash(obj)])) {
            entry = log[k][hashkey] = {
              m: obj,
              p: {}
            };
          }
          entry.p[key] = 1;
        }
      }
    },
    unwatch: function(key) {
      var observed, w, watch, _i, _len, _ref;
      if (w = watches[key]) {
        for (_i = 0, _len = w.length; _i < _len; _i++) {
          watch = w[_i];
          _ref = watch.w;
          for (key in _ref) {
            observed = _ref[key];
            observed.off(void 0, void 0, watch);
          }
        }
      }
    },
    watch: function(key, e, f) {
      var accesslog, c, context, logs, m, p, props, value, w, _, _ref, _ref1;
      if (!(w = watches[key])) {
        w = watches[key] = [];
      }
      w.push(context = {
        e: e,
        f: f,
        w: {}
      });
      log = {
        m: {},
        c: {},
        d: {}
      };
      try {
        value = e();
      } catch (_error) {}
      accesslog = log;
      log = false;
      _ref = {
        0: accesslog.m,
        1: accesslog.d
      };
      for (_ in _ref) {
        logs = _ref[_];
        for (key in logs) {
          m = logs[key];
          context.w[key] = m.m;
          if ((props = m.p)[void 0]) {
            m.m.on('all', onChange, context);
          } else {
            for (p in props) {
              m.m.on("change:" + p, onChange, context);
            }
          }
        }
      }
      _ref1 = accesslog.c;
      for (key in _ref1) {
        c = _ref1[key];
        context.w[key] = c;
        c.on('add', onChange, context);
        c.on('remove', onChange, context);
      }
      f(value);
    }
  };
});
