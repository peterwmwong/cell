// Generated by CoffeeScript 1.6.1

define(['util/hash', 'util/fn', 'util/type'], function(hash, fn, type) {
  var addLog, allChanges, doAfter, evaluateAndMonitor, log, logStack, onChange, onChangeCalled, watches, _onChange;
  logStack = [];
  onChangeCalled = log = false;
  addLog = function(obj, event, key) {
    if (!log.l[key = event + (key || hash(obj))]) {
      log.l[key] = {
        o: obj,
        e: event
      };
    }
  };
  doAfter = window.requestAnimationFrame || setTimeout;
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      evaluateAndMonitor(changes[key]);
    }
  };
  onChange = function() {
    allChanges[hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      doAfter(_onChange);
    }
  };
  evaluateAndMonitor = function(context) {
    var curLog, eventKey, prevLog, value;
    logStack.push(log);
    log = {
      l: curLog = {},
      c: {}
    };
    value = context.e();
    if (prevLog = context.l) {
      for (eventKey in prevLog) {
        if (curLog[eventKey]) {
          delete curLog[eventKey];
        } else {
          prevLog[eventKey].o.off(prevLog[eventKey].e, void 0, context);
        }
      }
    }
    for (eventKey in curLog) {
      curLog[eventKey].o.on(curLog[eventKey].e, onChange, context);
    }
    context.l = curLog;
    log = logStack.pop();
    context.f(value);
  };
  return {
    addCol: function() {
      var colKey;
      if (log) {
        log.c[colKey = hash(this)] = true;
        addLog(this, 'add', colKey);
        addLog(this, 'remove', colKey);
      }
    },
    addModel: function(key) {
      var c;
      if (log) {
        addLog(((c = this.collection) && log.c[hash(c)] ? c : this), key && ("change:" + key) || 'all');
      }
    },
    unwatch: function(key) {
      var context, i, w;
      if (w = watches[hash(key)]) {
        i = 0;
        while ((context = w[i++])) {
          for (key in context.l) {
            context.l[key].o.off(void 0, void 0, context);
          }
        }
      }
    },
    watch: function(keyObj, e, f, callContext) {
      var context, key;
      callContext || (callContext = keyObj);
      if (!type.isF(e)) {
        f.call(callContext, e);
      } else {
        (watches[key = hash(keyObj)] || (watches[key] = [])).push(context = {
          e: fn.b0(e, keyObj),
          f: fn.b1(f, callContext)
        });
        evaluateAndMonitor(context);
      }
    }
  };
});
