// Generated by CoffeeScript 1.6.1

define(['util/hash', 'util/fn', 'util/type'], function(hash, fn, type) {
  var addLog, allChanges, doAfter, evaluateAndMonitor, log, logObjMap, onChange, onChangeCalled, watches, _onChange;
  onChangeCalled = logObjMap = log = false;
  addLog = function(obj, event) {
    var key;
    (log[key = hash(obj)] || (log[key] = {}))[event] = true;
    logObjMap[key] = obj;
  };
  doAfter = window.requestAnimationFrame || setTimeout;
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      evaluateAndMonitor(changes[key]);
    }
  };
  onChange = function() {
    allChanges[hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      doAfter(_onChange);
    }
  };
  evaluateAndMonitor = function(context) {
    var accesslog, accesslogObjMap, event, events, i, key, keyEvent, obj, prevObjMap, prevlog, removes, value;
    log = {};
    logObjMap = {};
    value = context.e();
    accesslog = log;
    accesslogObjMap = logObjMap;
    logObjMap = log = false;
    if (prevlog = context.l) {
      prevObjMap = context.w;
      removes = [];
      for (key in prevlog) {
        events = prevlog[key];
        for (event in events) {
          if (accesslog[key][event]) {
            delete accesslog[key][event];
          } else {
            removes.push([key, event]);
          }
        }
      }
      i = 0;
      while (keyEvent = removes[i++]) {
        prevObjMap[keyEvent[0]].off(keyEvent[1], void 0, context);
      }
    }
    context.l = accesslog;
    context.w = accesslogObjMap;
    for (key in accesslog) {
      obj = accesslogObjMap[key];
      for (event in accesslog[key]) {
        obj.on(event, onChange, context);
      }
    }
    context.f(value);
  };
  return {
    addCol: function() {
      if (log) {
        addLog(this, 'add');
        addLog(this, 'remove');
      }
    },
    addModel: function(key) {
      var c;
      if (log) {
        addLog(((c = this.collection) && logObjMap[hash(c)] ? c : this), key && ("change:" + key) || 'all');
      }
    },
    unwatch: function(key) {
      var observed, w, watch, _i, _len, _ref;
      if (w = watches[key = hash(key)]) {
        for (_i = 0, _len = w.length; _i < _len; _i++) {
          watch = w[_i];
          _ref = watch.w;
          for (key in _ref) {
            observed = _ref[key];
            observed.off(void 0, void 0, watch);
          }
        }
      }
    },
    watch: function(key, e, f, callContext) {
      var context, obj, w;
      callContext || (callContext = key);
      if (!type.isF(e)) {
        f.call(callContext, e);
      } else {
        obj = key;
        ((w = watches[key = hash(key)]) ? w : (watches[key] = [])).push(context = {
          e: fn.b0(e, obj),
          f: fn.b1(f, callContext),
          w: {}
        });
        evaluateAndMonitor(context);
      }
    }
  };
});
