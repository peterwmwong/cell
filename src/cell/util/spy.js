// Generated by CoffeeScript 1.6.1

define(['util/hash', 'util/fn', 'util/type', 'util/defer'], function(hash, fn, type, defer) {
  var allChanges, evaluateAndMonitor, logStack, logc, logl, logs, onChange, onChangeCalled, watches, _onChange;
  logStack = [];
  onChangeCalled = logl = logs = logc = false;
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      evaluateAndMonitor(changes[key]);
    }
  };
  onChange = function() {
    allChanges[this.$$hashkey || hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      defer(_onChange);
    }
  };
  return {
    _eam: evaluateAndMonitor = function(context) {
      var eventKey, prevLog, value, _ref;
      logStack.push([logs, logc, logl]);
      logs = '';
      logl = {};
      logc = {};
      value = context.e();
      if (logs !== context.s) {
        if (prevLog = context.l) {
          for (eventKey in prevLog) {
            if (logl[eventKey]) {
              delete logl[eventKey];
            } else {
              prevLog[eventKey].o.off(prevLog[eventKey].e, void 0, context);
            }
          }
        }
        for (eventKey in logl) {
          logl[eventKey].o.on(logl[eventKey].e, onChange, context);
        }
        context.s = logs;
        context.l = logl;
      }
      _ref = logStack.pop(), logs = _ref[0], logc = _ref[1], logl = _ref[2];
      context.f(value);
    },
    addCol: function() {
      var key;
      if (logl && !logc[key = this.$$hashkey]) {
        logs += key;
        logc[key] = true;
        logl['add' + key] = {
          o: this,
          e: 'add'
        };
        logl['remove' + key] = {
          o: this,
          e: 'remove'
        };
      }
    },
    addModel: function(event) {
      var eventKey, key, obj;
      if (logl) {
        eventKey = event + ((obj = this.collection) && logc[key = obj.$$hashkey] ? key : (obj = this, this.$$hashkey));
        if (!logl[eventKey]) {
          logs += eventKey;
          logl[eventKey] = {
            o: obj,
            e: event
          };
        }
      }
    },
    suspendWatch: function(f) {
      var suspendedLogc, suspendedLogl, suspendedLogs;
      suspendedLogl = logl;
      suspendedLogs = logs;
      suspendedLogc = logs;
      logl = logs = logc = void 0;
      try {
        f();
      } catch (_error) {}
      logl = suspendedLogl;
      logs = suspendedLogs;
      logc = suspendedLogc;
    },
    unwatch: function(key) {
      var context, i, w;
      if (w = watches[key = hash(key)]) {
        delete watches[key];
        i = 0;
        while ((context = w[i++])) {
          for (key in context.l) {
            context.l[key].o.off(void 0, void 0, context);
          }
        }
      }
    },
    watch: function(keyObj, e, f, callContext) {
      var context, key;
      callContext || (callContext = keyObj);
      if (!type.isF(e)) {
        f.call(callContext, e);
      } else {
        (watches[key = hash(keyObj)] || (watches[key] = [])).push(context = {
          e: fn.b0(e, keyObj),
          f: fn.b1(f, callContext)
        });
        evaluateAndMonitor(context);
        return context;
      }
    }
  };
});
