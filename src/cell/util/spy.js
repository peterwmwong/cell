// Generated by CoffeeScript 1.6.1

define(['util/hash', 'util/fn', 'util/type', 'util/defer'], function(hash, fn, type, defer) {
  var addLog, allChanges, evaluateAndMonitor, log, logStack, onChange, onChangeCalled, watches, _onChange;
  logStack = [];
  onChangeCalled = log = false;
  addLog = function(obj, event, key) {
    if (!log.l[key = event + (key || hash(obj))]) {
      log.l[key] = {
        o: obj,
        e: event
      };
    }
  };
  allChanges = {};
  watches = {};
  _onChange = function() {
    var changes, key;
    onChangeCalled = false;
    changes = allChanges;
    allChanges = {};
    for (key in changes) {
      evaluateAndMonitor(changes[key]);
    }
  };
  onChange = function() {
    allChanges[hash(this)] = this;
    if (!onChangeCalled) {
      onChangeCalled = true;
      defer(_onChange);
    }
  };
  return {
    _eam: evaluateAndMonitor = function(context) {
      var curLog, eventKey, prevLog, value;
      logStack.push(log);
      log = {
        l: curLog = {},
        c: {}
      };
      value = context.e();
      if (prevLog = context.l) {
        for (eventKey in prevLog) {
          if (curLog[eventKey]) {
            delete curLog[eventKey];
          } else {
            prevLog[eventKey].o.off(prevLog[eventKey].e, void 0, context);
          }
        }
      }
      for (eventKey in curLog) {
        curLog[eventKey].o.on(curLog[eventKey].e, onChange, context);
      }
      context.l = curLog;
      log = logStack.pop();
      context.f(value);
      return context;
    },
    addCol: function() {
      var colKey;
      if (log) {
        log.c[colKey = hash(this)] = true;
        addLog(this, 'add', colKey);
        addLog(this, 'remove', colKey);
      }
    },
    addModel: function(key) {
      var c;
      if (log) {
        addLog(((c = this.collection) && log.c[hash(c)] ? c : this), key && ("change:" + key) || 'all');
      }
    },
    unwatch: function(key) {
      var context, i, w;
      if (w = watches[key = hash(key)]) {
        delete watches[key];
        i = 0;
        while ((context = w[i++])) {
          for (key in context.l) {
            context.l[key].o.off(void 0, void 0, context);
          }
        }
      }
    },
    watch: function(keyObj, e, f, callContext) {
      var context, key;
      callContext || (callContext = keyObj);
      if (!type.isF(e)) {
        f.call(callContext, e);
      } else {
        (watches[key = hash(keyObj)] || (watches[key] = [])).push(context = {
          e: fn.b0(e, keyObj),
          f: fn.b1(f, callContext)
        });
        evaluateAndMonitor(context);
      }
    }
  };
});
