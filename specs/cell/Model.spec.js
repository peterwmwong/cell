// Generated by CoffeeScript 1.4.0

define(function() {
  return function(_arg) {
    var NON_STRINGS, beforeEachRequire;
    beforeEachRequire = _arg.beforeEachRequire;
    NON_STRINGS = [void 0, null, 5, (function() {}), [], {}];
    beforeEachRequire(['cell/Model'], function(Model) {
      this.Model = Model;
    });
    describe('@constructor(initial_hash)', function() {
      describe('when initial_hash is NOT undefined', function() {
        beforeEach(function() {
          return this.model = new this.Model({
            a: 'a val',
            b: 'b val',
            c: 'c val'
          });
        });
        return it('current attributes are same as initial_hash', function() {
          var k, v, _ref, _results;
          _ref = {
            a: 'a val',
            b: 'b val',
            c: 'c val'
          };
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(expect(this.model.get(k)).toBe(v));
          }
          return _results;
        });
      });
      return describe('when initial_hash is undefined', function() {
        beforeEach(function() {
          return this.model = new this.Model();
        });
        return it('current attributes are same as initial_hash', function() {
          return expect(this.model._a).toEqual({});
        });
      });
    });
    describe('@get(key)', function() {
      beforeEach(function() {
        return this.model = new this.Model({
          a: 'a val',
          b: 'b val',
          c: 'c val'
        });
      });
      describe('when key is not already set', function() {
        return it('returns undefined', function() {
          return expect(this.model.get('z')).toBe(void 0);
        });
      });
      describe('when key is set', function() {
        return it('returns value of key', function() {
          return expect(this.model.get('a')).toBe('a val');
        });
      });
      return describe('when key is invalid (non-string)', function() {
        return it('returns undefined', function() {
          var key, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = NON_STRINGS.length; _i < _len; _i++) {
            key = NON_STRINGS[_i];
            _results.push(expect(this.model.get(key)).toBe(void 0));
          }
          return _results;
        });
      });
    });
    describe('@set(key,value)', function() {
      beforeEach(function() {
        return this.model = new this.Model({
          a: 'a val',
          b: 'b val',
          c: 'c val'
        });
      });
      describe('when overwriting with a different value', function() {
        beforeEach(function() {
          this.model.on('change:b', (this.on_change_spy = jasmine.createSpy('change:b')));
          return this.model.set('b', 'new b value');
        });
        it('sets the new value', function() {
          return expect(this.model.get('b')).toBe('new b value');
        });
        return it('fires one "change:b" event', function() {
          expect(this.on_change_spy.argsForCall.length).toBe(1);
          return expect(this.on_change_spy).toHaveBeenCalledWith('change:b', 'new b value', 'b val');
        });
      });
      describe('when overwriting with the same value', function() {
        beforeEach(function() {
          this.model.on('change:b', (this.on_change_spy = jasmine.createSpy('change:b')));
          return this.model.set('b', 'b val');
        });
        it('value continues to be the same', function() {
          return expect(this.model.get('b')).toBe('b val');
        });
        return it('does NOT fire a "change:b" event', function() {
          return expect(this.on_change_spy).not.toHaveBeenCalled();
        });
      });
      return describe('when key is invalid (non-string)', function() {
        var key, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = NON_STRINGS.length; _i < _len; _i++) {
          key = NON_STRINGS[_i];
          _results.push((function(key) {
            beforeEach(function() {
              this.model.on('change:a', (this.on_change_spy_a = jasmine.createSpy('change:a')));
              this.model.on('change:b', (this.on_change_spy_b = jasmine.createSpy('change:b')));
              this.model.on('change:c', (this.on_change_spy_c = jasmine.createSpy('change:c')));
              return this.model.set(key, 'blah');
            });
            it('no values are changed', function() {
              expect(this.model.get('a')).toBe('a val');
              expect(this.model.get('b')).toBe('b val');
              return expect(this.model.get('c')).toBe('c val');
            });
            return it('no change events were fired', function() {
              expect(this.on_change_spy_a).not.toHaveBeenCalled();
              expect(this.on_change_spy_b).not.toHaveBeenCalled();
              return expect(this.on_change_spy_c).not.toHaveBeenCalled();
            });
          })(key));
        }
        return _results;
      });
    });
    describe('@off( type?:string, fn?:function, ctx?:object )', function() {
      beforeEach(function() {
        this.model = new this.Model({
          a: 'a val'
        });
        this.model.on('custom', (this.handler = jasmine.createSpy('custom')), (this.ctx = {}));
        this.model.on('custom', (this.handler2 = jasmine.createSpy('custom (2)')), this.ctx);
        this.model.on('custom', this.handler, (this.ctx2 = {}));
        return this.model.on('custom2', this.handler2, this.ctx);
      });
      describe('@off( type:string, fn:function )', function() {
        beforeEach(function() {
          this.model.off('custom', this.handler);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler).not.toHaveBeenCalled();
          expect(this.handler2).toHaveBeenCalledWith('custom');
          return expect(this.handler2.calls[0].object).toBe(this.ctx);
        });
      });
      describe('@off( type:string, fn:function, ctx:object )', function() {
        beforeEach(function() {
          this.model.off('custom', this.handler, this.ctx);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler.calls.length).toBe(1);
          expect(this.handler).toHaveBeenCalledWith('custom');
          expect(this.handler.calls[0].object).toBe(this.ctx2);
          expect(this.handler2).toHaveBeenCalledWith('custom');
          return expect(this.handler2.calls[0].object).toBe(this.ctx);
        });
      });
      describe('@off( type:string, undefined, ctx:object )', function() {
        beforeEach(function() {
          this.model.off('custom', void 0, this.ctx);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler.calls.length).toBe(1);
          expect(this.handler).toHaveBeenCalledWith('custom');
          expect(this.handler.calls[0].object).toBe(this.ctx2);
          expect(this.handler2).not.toHaveBeenCalled();
          this.model.trigger('custom2');
          return expect(this.handler2).toHaveBeenCalledWith('custom2');
        });
      });
      describe('@off( undefined, fn:function )', function() {
        beforeEach(function() {
          this.model.off(void 0, this.handler2);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler.calls.length).toBe(2);
          expect(this.handler).toHaveBeenCalledWith('custom');
          expect(this.handler.calls[0].object).toBe(this.ctx2);
          expect(this.handler.calls[1].object).toBe(this.ctx);
          expect(this.handler2).not.toHaveBeenCalled();
          this.model.trigger('custom2');
          return expect(this.handler2).not.toHaveBeenCalled();
        });
      });
      describe('@off( undefined, fn:function, ctx:object )', function() {
        beforeEach(function() {
          this.model.off(void 0, this.handler, this.ctx);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler.calls.length).toBe(1);
          expect(this.handler).toHaveBeenCalledWith('custom');
          expect(this.handler.calls[0].object).toBe(this.ctx2);
          expect(this.handler2).toHaveBeenCalledWith('custom');
          this.handler2.reset();
          this.model.trigger('custom2');
          expect(this.handler2).toHaveBeenCalled();
          return expect(this.handler2.calls[0].object).toBe(this.ctx);
        });
      });
      return describe('@off( undefined, undefined, ctx:object )', function() {
        beforeEach(function() {
          this.model.off(void 0, void 0, this.ctx);
          return this.model.trigger('custom');
        });
        return it('should unregister all matching handlers', function() {
          expect(this.handler.calls.length).toBe(1);
          expect(this.handler).toHaveBeenCalledWith('custom');
          expect(this.handler.calls[0].object).toBe(this.ctx2);
          expect(this.handler2).not.toHaveBeenCalled();
          this.handler2.reset();
          this.model.trigger('custom2');
          return expect(this.handler2).not.toHaveBeenCalled();
        });
      });
    });
    describe('@on(type:string, handler:function, ctx?:object)', function() {
      beforeEach(function() {
        this.model = new this.Model({
          a: 'a val'
        });
        this.model.on('custom', (this.customHandler = jasmine.createSpy('custom')));
        return this.model.on('custom with context', (this.customHandlerWithContext = jasmine.createSpy('custom with context')), this.ctx = {});
      });
      it('registers a handler to be called upon triggering', function() {
        this.model.trigger('notRight');
        this.model.set('a', 'a val 2');
        expect(this.customHandler).not.toHaveBeenCalled();
        expect(this.customHandlerWithContext).not.toHaveBeenCalled();
        this.model.trigger('custom');
        expect(this.customHandler).toHaveBeenCalledWith('custom');
        expect(this.customHandlerWithContext).not.toHaveBeenCalled();
        this.customHandler.reset();
        this.model.trigger('custom with context');
        expect(this.customHandler).not.toHaveBeenCalled();
        expect(this.customHandlerWithContext).toHaveBeenCalledWith('custom with context');
        expect(this.customHandlerWithContext.calls[0].object).toBe(this.ctx);
        this.customHandler.reset();
        return this.customHandlerWithContext.reset();
      });
      return it('when type is "any", calls handler upon any triggering', function() {
        var anyCtx, anyHandler, arg1, arg2, arg3;
        this.model.on('any', (anyHandler = jasmine.createSpy('any')), (anyCtx = {}));
        this.model.trigger('blah', (arg1 = {}), (arg2 = {}), (arg3 = {}));
        expect(anyHandler).toHaveBeenCalledWith('blah', arg1, arg2, arg3);
        expect(anyHandler.calls[0].object).toBe(anyCtx);
        anyHandler.reset();
        this.model.set('a', 'a val 2');
        expect(anyHandler).toHaveBeenCalledWith('change:a', 'a val 2', 'a val');
        return expect(anyHandler.calls[0].object).toBe(anyCtx);
      });
    });
    describe('@trigger(type:string, args...:any)', function() {
      beforeEach(function() {
        this.model = new this.Model({
          a: 'a val'
        });
        return this.model.on('custom', (this.customHandler = jasmine.createSpy('custom')));
      });
      return it('calls handler with arguments', function() {
        this.model.trigger('custom');
        expect(this.customHandler).toHaveBeenCalledWith('custom');
        this.customHandler.reset();
        this.model.trigger('custom', (this.arg1 = {}), (this.arg2 = {}));
        return expect(this.customHandler).toHaveBeenCalledWith('custom', this.arg1, this.arg2);
      });
    });
    return describe('@onChangeAndDo(propertyName:string, change_handler:function)', function() {
      beforeEach(function() {
        return this.model = new this.Model({
          a: 'a val',
          b: 'b val',
          c: 'c val'
        });
      });
      it('calls change_handler with current value of key', function() {
        var change_handler;
        this.model.onChangeAndDo('a', (change_handler = jasmine.createSpy('change_handler')));
        expect(change_handler.argsForCall.length).toBe(1);
        return expect(change_handler).toHaveBeenCalledWith('initial:a', 'a val');
      });
      return it('calls change_handler when key is changed', function() {
        var change_handler;
        this.model.onChangeAndDo('a', (change_handler = jasmine.createSpy('change_handler')));
        change_handler.reset();
        this.model.set('a', 'a new val');
        expect(change_handler.argsForCall.length).toBe(1);
        return expect(change_handler).toHaveBeenCalledWith('change:a', 'a new val', 'a val');
      });
    });
  };
});
