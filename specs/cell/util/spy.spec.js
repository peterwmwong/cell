// Generated by CoffeeScript 1.4.0

define(function() {
  return function(_arg) {
    var beforeEachRequire;
    beforeEachRequire = _arg.beforeEachRequire;
    beforeEachRequire(['cell/Model', 'cell/Collection', 'cell/util/spy'], function(Model, Collection, spy) {
      this.Model = Model;
      this.Collection = Collection;
      this.spy = spy;
      return this.watch = this.spy.watch;
    });
    return describe('@watch( func:function, callback:function )', function() {
      beforeEach(function() {
        this.value = {};
        return this.callback = jasmine.createSpy('callback');
      });
      describe("When func does NOT access any Model or Collection", function() {
        beforeEach(function() {
          this.func = jasmine.createSpy('func').andReturn(this.value);
          return this.watch(this.func, this.callback);
        });
        return it('call callback with result of func', function() {
          expect(this.func).toHaveBeenCalled();
          expect(this.func.callCount).toBe(1);
          expect(this.callback).toHaveBeenCalledWith(this.value);
          return expect(this.callback.callCount).toBe(1);
        });
      });
      describe("When func accesses a Model's attributes()", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            return _this.model.attributes();
          });
          return this.watch(this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
          return expect(this.callback.callCount).toBe(1);
        });
        return describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            expect(this.func.callCount).toBe(1);
            expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
            return expect(this.callback.callCount).toBe(1);
          });
        });
      });
      describe("When func accesses a Model's attributes() and a property", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model.get('a');
            return _this.model.attributes();
          });
          return this.watch(this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
          return expect(this.callback.callCount).toBe(1);
        });
        return describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            expect(this.func.callCount).toBe(1);
            expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
            return expect(this.callback.callCount).toBe(1);
          });
        });
      });
      describe("When func accesses multiple Models", function() {
        beforeEach(function() {
          var _this = this;
          this.model1 = new this.Model({
            a: 1
          });
          this.model2 = new this.Model({
            b: 2
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model1.get('a');
            return _this.model2.get('b');
          });
          return this.watch(this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.callback).toHaveBeenCalledWith(2);
          return expect(this.callback.callCount).toBe(1);
        });
        describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model1.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            expect(this.func.callCount).toBe(1);
            expect(this.callback).toHaveBeenCalledWith(2);
            return expect(this.callback.callCount).toBe(1);
          });
        });
        return describe('when the other accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model2.set('b', 3);
          });
          return it('calls callback with result of func', function() {
            expect(this.func.callCount).toBe(1);
            expect(this.callback).toHaveBeenCalledWith(3);
            return expect(this.callback.callCount).toBe(1);
          });
        });
      });
      describe("When func accesses a Model's properties", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model.get('c');
            return _this.model.get('a');
          });
          return this.watch(this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func).toHaveBeenCalled();
          expect(this.func.callCount).toBe(1);
          expect(this.callback).toHaveBeenCalledWith(1);
          return expect(this.callback.callCount).toBe(1);
        });
        describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          it('calls callback with result of func', function() {
            expect(this.func).toHaveBeenCalled();
            expect(this.func.callCount).toBe(1);
            expect(this.callback).toHaveBeenCalledWith(2);
            return expect(this.callback.callCount).toBe(1);
          });
          return describe('when another accessed model property changes', function() {
            beforeEach(function() {
              this.func.reset();
              this.callback.reset();
              return this.model.set('c', 'y');
            });
            return it('calls callback with result of func', function() {
              expect(this.func).toHaveBeenCalled();
              expect(this.func.callCount).toBe(1);
              expect(this.callback).toHaveBeenCalledWith(2);
              return expect(this.callback.callCount).toBe(1);
            });
          });
        });
        return describe('when another model property changes or other non-relevant events occur', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            this.model.set('b', 2);
            return this.model.trigger('bogus');
          });
          return it('calls callback with result of func', function() {
            expect(this.func).not.toHaveBeenCalled();
            return expect(this.callback).not.toHaveBeenCalled();
          });
        });
      });
      return describe("When func accesses a Collection", function() {
        var access, methodAccess, methodName, _results;
        beforeEach(function() {
          return this.col = new this.Collection({
            x: 'x val',
            y: 'y val'
          });
        });
        methodAccess = {
          at: function() {
            return this.col.at(0);
          },
          length: function() {
            return this.col.length();
          },
          indexOf: function() {
            return this.col.indexOf({});
          },
          toArray: function() {
            return this.col.toArray();
          },
          each: function() {
            return this.col.each(function() {});
          },
          map: function() {
            return this.col.map(function() {});
          },
          reduce: function() {
            return this.col.reduce(0, function() {});
          }
        };
        _results = [];
        for (methodName in methodAccess) {
          access = methodAccess[methodName];
          _results.push((function(methodName, access) {
            return describe("by calling " + methodName + "()", function() {
              var changeDesc, changeFunc, changes, _results1;
              beforeEach(function() {
                var result,
                  _this = this;
                result = 1;
                this.func = jasmine.createSpy('func').andCallFake(function() {
                  access.call(_this);
                  return result++;
                });
                this.watch(this.func, this.callback);
                this.callback.reset();
                return this.func.reset();
              });
              changes = {
                'a model was added': function() {
                  return this.col.add({
                    x: 'another x val'
                  });
                },
                'a model was removed': function() {
                  return this.col.remove(this.col.at(0));
                }
              };
              _results1 = [];
              for (changeDesc in changes) {
                changeFunc = changes[changeDesc];
                _results1.push((function(changeDesc, changeFunc) {
                  return describe("when the collection changes because " + changeDesc, function() {
                    beforeEach(function() {
                      return changeFunc.call(this);
                    });
                    return it('calls callback with result of func', function() {
                      expect(this.func).toHaveBeenCalled();
                      expect(this.func.callCount).toBe(1);
                      expect(this.callback).toHaveBeenCalledWith(2);
                      return expect(this.callback.callCount).toBe(1);
                    });
                  });
                })(changeDesc, changeFunc));
              }
              return _results1;
            });
          })(methodName, access));
        }
        return _results;
      });
    });
  };
});
