// Generated by CoffeeScript 1.6.1

define(['../../utils/spec-utils'], function(_arg) {
  var waitOne;
  waitOne = _arg.waitOne;
  return function(_arg1) {
    var beforeEachRequire;
    beforeEachRequire = _arg1.beforeEachRequire;
    beforeEachRequire(['cell/Model', 'cell/Collection', 'cell/util/spy'], function(Model, Collection, spy) {
      this.Model = Model;
      this.Collection = Collection;
      this.spy = spy;
      this.watch = this.spy.watch;
      return this.unwatch = this.spy.unwatch;
    });
    describe('@unwatch( context:any )', function() {
      beforeEach(function() {
        var _this = this;
        this.model = new this.Model({
          a: 1,
          b: {},
          c: 'x'
        });
        this.callback = jasmine.createSpy('callback');
        this.func = jasmine.createSpy('func').andCallFake(function() {
          return _this.model.attributes();
        });
        this.callback2 = jasmine.createSpy('callback');
        this.func2 = jasmine.createSpy('func').andCallFake(function() {
          return _this.model.attributes();
        });
        this.context = 'key1';
        this.watch(this.context, this.func, this.callback);
        this.watch('key2', this.func2, this.callback2);
        this.callback.reset();
        this.func.reset();
        this.callback2.reset();
        return this.func2.reset();
      });
      it('removes all watched expressions registered under key', function() {
        this.unwatch(this.context);
        this.model.set('a', 2);
        return waitOne(function() {
          expect(this.callback).not.toHaveBeenCalled();
          expect(this.func).not.toHaveBeenCalled();
          expect(this.callback2).toHaveBeenCalled();
          return expect(this.func2).toHaveBeenCalled();
        });
      });
      it('removes all watched expressions registered ONLY under key', function() {
        this.unwatch('key2');
        this.model.set('a', 2);
        return waitOne(function() {
          expect(this.callback).toHaveBeenCalled();
          expect(this.func).toHaveBeenCalled();
          expect(this.callback2).not.toHaveBeenCalled();
          return expect(this.func2).not.toHaveBeenCalled();
        });
      });
      return it('does nothing if key has no watches', function() {
        this.unwatch('bogus key');
        this.model.set('a', 2);
        return waitOne(function() {
          expect(this.callback).toHaveBeenCalled();
          expect(this.func).toHaveBeenCalled();
          expect(this.callback2).toHaveBeenCalled();
          return expect(this.func2).toHaveBeenCalled();
        });
      });
    });
    return describe('@watch( context:any, func:function, callback:function, callContext?:any )', function() {
      beforeEach(function() {
        this.context = {};
        this.value = {};
        return this.callback = jasmine.createSpy('callback');
      });
      describe("when callContext is specified", function() {
        beforeEach(function() {
          var _this = this;
          this.callContext = {};
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            return _this.model.attributes();
          });
          return this.watch(this.context, this.func, this.callback, this.callContext);
        });
        it('calls callback with result of func with callContext as `this`', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.func.calls[0].object).toBe(this.context);
          expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
          expect(this.callback.callCount).toBe(1);
          return expect(this.callback.calls[0].object).toBe(this.callContext);
        });
        return describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.callContext);
            });
          });
        });
      });
      describe("When func does NOT access any Model or Collection", function() {
        beforeEach(function() {
          this.func = jasmine.createSpy('func').andReturn(this.value);
          return this.watch(this.context, this.func, this.callback);
        });
        return it('call callback with result of func', function() {
          var done;
          done = false;
          runs(function() {
            return setTimeout((function() {
              return done = true;
            }), 1);
          });
          waitsFor(function() {
            return done;
          });
          return runs(function() {
            expect(this.func.callCount).toBe(1);
            expect(this.func.calls[0].object).toBe(this.context);
            expect(this.callback).toHaveBeenCalledWith(this.value);
            expect(this.callback.callCount).toBe(1);
            return expect(this.callback.calls[0].object).toBe(this.context);
          });
        });
      });
      describe("When func accesses a Model's attributes()", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            return _this.model.attributes();
          });
          return this.watch(this.context, this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.func.calls[0].object).toBe(this.context);
          expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
          expect(this.callback.callCount).toBe(1);
          return expect(this.callback.calls[0].object).toBe(this.context);
        });
        return describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.context);
            });
          });
        });
      });
      describe("When func accesses a Model's attributes() and a property", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model.get('a');
            return _this.model.attributes();
          });
          return this.watch(this.context, this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.func.calls[0].object).toBe(this.context);
          expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
          expect(this.callback.callCount).toBe(1);
          return expect(this.callback.calls[0].object).toBe(this.context);
        });
        return describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.callback).toHaveBeenCalledWith(this.model.attributes());
              return expect(this.callback.callCount).toBe(1);
            });
          });
        });
      });
      describe("When func accesses multiple Models", function() {
        beforeEach(function() {
          var _this = this;
          this.model1 = new this.Model({
            a: 1
          });
          this.model2 = new this.Model({
            b: 2
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model1.get('a');
            return _this.model2.get('b');
          });
          return this.watch(this.context, this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.func.calls[0].object).toBe(this.context);
          expect(this.callback).toHaveBeenCalledWith(2);
          expect(this.callback.callCount).toBe(1);
          return expect(this.callback.calls[0].object).toBe(this.context);
        });
        describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model1.set('a', 2);
          });
          return it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback).toHaveBeenCalledWith(2);
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.context);
            });
          });
        });
        return describe('when the other accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model2.set('b', 3);
          });
          return it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback).toHaveBeenCalledWith(3);
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.context);
            });
          });
        });
      });
      describe("When func accesses a Model's properties", function() {
        beforeEach(function() {
          var _this = this;
          this.model = new this.Model({
            a: 1,
            b: {},
            c: 'x'
          });
          this.func = jasmine.createSpy('func').andCallFake(function() {
            _this.model.get('c');
            return _this.model.get('a');
          });
          return this.watch(this.context, this.func, this.callback);
        });
        it('call @callback with result of func', function() {
          expect(this.func.callCount).toBe(1);
          expect(this.func.calls[0].object).toBe(this.context);
          expect(this.callback).toHaveBeenCalledWith(1);
          expect(this.callback.callCount).toBe(1);
          return expect(this.callback.calls[0].object).toBe(this.context);
        });
        describe('when the accessed model property changes', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            return this.model.set('a', 2);
          });
          it('calls callback with result of func', function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback).toHaveBeenCalledWith(2);
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.context);
            });
          });
          return describe('when another accessed model property changes', function() {
            beforeEach(function() {
              this.func.reset();
              this.callback.reset();
              return this.model.set('c', 'y');
            });
            return it('calls callback with result of func', function() {
              return waitOne(function() {
                expect(this.func.callCount).toBe(1);
                expect(this.func.calls[0].object).toBe(this.context);
                expect(this.callback).toHaveBeenCalledWith(2);
                expect(this.callback.callCount).toBe(1);
                return expect(this.callback.calls[0].object).toBe(this.context);
              });
            });
          });
        });
        return describe('when another model property changes or other non-relevant events occur', function() {
          beforeEach(function() {
            this.func.reset();
            this.callback.reset();
            this.model.set('b', 2);
            return this.model.trigger('bogus');
          });
          return it('calls callback with result of func', function() {
            expect(this.func).not.toHaveBeenCalled();
            return expect(this.callback).not.toHaveBeenCalled();
          });
        });
      });
      describe("When func accesses a Model part of a Collection", function() {
        beforeEach(function() {
          var _this = this;
          this.col = new this.Collection([
            {
              x: 'x val'
            }, {
              y: 'y val'
            }
          ]);
          this.model0 = this.col.at(0);
          this.model1 = this.col.at(1);
          this.func = jasmine.createSpy('func').andCallFake(function() {
            return _this.col.at(0).get('x');
          });
          this.watch(this.context, this.func, this.callback);
          this.func.reset();
          return this.callback.reset();
        });
        it('calls func when an accessed a Model attribute changes in a Collection', function() {
          this.model1.set('x', 'a value');
          return waitOne(function() {
            expect(this.func.callCount).toBe(1);
            expect(this.func.calls[0].object).toBe(this.context);
            expect(this.callback).toHaveBeenCalledWith('x val');
            expect(this.callback.callCount).toBe(1);
            return expect(this.callback.calls[0].object).toBe(this.context);
          });
        });
        return it('calls func when an accessed a Model attribute changes in a Collection of another Model', function() {
          this.model0.set('x', 'a value');
          return waitOne(function() {
            expect(this.func.callCount).toBe(1);
            expect(this.func.calls[0].object).toBe(this.context);
            expect(this.callback).toHaveBeenCalledWith('a value');
            expect(this.callback.callCount).toBe(1);
            return expect(this.callback.calls[0].object).toBe(this.context);
          });
        });
      });
      describe("When func accesses a Collection using filterBy() (Model attribute access is implied)", function() {
        beforeEach(function() {
          var _this = this;
          this.col = new this.Collection([
            {
              x: 'x val'
            }, {
              y: 'y val'
            }
          ]);
          this.func = jasmine.createSpy('func').andCallFake(function() {
            return _this.col.filterBy({
              x: 'x val'
            });
          });
          this.watch(this.context, this.func, this.callback);
          this.func.reset();
          return this.callback.reset();
        });
        return describe("and an accessed Model attribute changes", function() {
          beforeEach(function() {
            return this.col.at(1).set('x', 'x val 2');
          });
          return it("calls callback with result of func", function() {
            return waitOne(function() {
              expect(this.func.callCount).toBe(1);
              expect(this.func.calls[0].object).toBe(this.context);
              expect(this.callback.calls[0].args[0][0]).toBe(this.col.at(0));
              expect(this.callback.callCount).toBe(1);
              return expect(this.callback.calls[0].object).toBe(this.context);
            });
          });
        });
      });
      return describe("When func accesses a Collection", function() {
        var access, methodAccess, methodName, _results;
        beforeEach(function() {
          return this.col = new this.Collection([
            {
              x: 'x val'
            }, {
              y: 'y val'
            }
          ]);
        });
        methodAccess = {
          at: function() {
            return this.col.at(0);
          },
          length: function() {
            return this.col.length();
          },
          indexOf: function() {
            return this.col.indexOf({});
          },
          toArray: function() {
            return this.col.toArray();
          },
          each: function() {
            return this.col.each(function() {});
          },
          map: function() {
            return this.col.map(function() {});
          },
          filterBy: function() {
            return this.col.filterBy({
              a: 1
            });
          },
          reduce: function() {
            return this.col.reduce(0, function() {});
          }
        };
        _results = [];
        for (methodName in methodAccess) {
          access = methodAccess[methodName];
          _results.push((function(methodName, access) {
            return describe("by calling " + methodName + "()", function() {
              var changeDesc, changeFunc, changes, _results1;
              beforeEach(function() {
                var result,
                  _this = this;
                result = 1;
                this.func = jasmine.createSpy('func').andCallFake(function() {
                  access.call(_this);
                  return result++;
                });
                this.watch(this.context, this.func, this.callback);
                this.callback.reset();
                return this.func.reset();
              });
              changes = {
                'a model was added': function() {
                  return this.col.add({
                    x: 'another x val'
                  });
                },
                'a model was removed': function() {
                  return this.col.remove(this.col.at(0));
                }
              };
              _results1 = [];
              for (changeDesc in changes) {
                changeFunc = changes[changeDesc];
                _results1.push((function(changeDesc, changeFunc) {
                  return describe("when the collection changes because " + changeDesc, function() {
                    beforeEach(function() {
                      return changeFunc.call(this);
                    });
                    return it('calls callback with result of func', function() {
                      return waitOne(function() {
                        expect(this.func.callCount).toBe(1);
                        expect(this.func.calls[0].object).toBe(this.context);
                        expect(this.callback).toHaveBeenCalledWith(2);
                        expect(this.callback.callCount).toBe(1);
                        return expect(this.callback.calls[0].object).toBe(this.context);
                      });
                    });
                  });
                })(changeDesc, changeFunc));
              }
              return _results1;
            });
          })(methodName, access));
        }
        return _results;
      });
    });
  };
});
